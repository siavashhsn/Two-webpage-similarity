 Boost C libraries Wikipedia the free encyclopedia Boost C libraries From Wikipedia the free encyclopedia Jump to navigation search Boost C libraries Boost logo Stable release December months ago Written in C Type Libraries License Boost Software License Website www boost org Boost is a set of libraries for the C programming language that provide support for tasks and structures such as linear algebra pseudorandom number generation multithreading image processing regular expressions and unit testing It contains over eighty individual libraries Most of the Boost libraries are licensed under the Boost Software License designed to allow Boost to be used with both free and proprietary software projects Many of Boost s founders are on the C standards committee and several Boost libraries have been accepted for incorporation into both the C Technical Report and the C standard Contents Design Associated people License See also References Further reading External links Design edit The libraries are aimed at a wide range of C users and application domains They range from general purpose libraries like the smart pointer library to operating system abstractions like Boost FileSystem to libraries primarily aimed at other library developers and advanced C users like the template metaprogramming MPL and domain specific language DSL creation Proto In order to ensure efficiency and flexibility Boost makes extensive use of templates Boost has been a source of extensive work and research into generic programming and metaprogramming in C citation needed Most Boost libraries are header based consisting of inline functions and templates and as such do not need to be built in advance of their use Some Boost libraries coexist as independent libraries Associated people edit Original founders of Boost still active in the community include Beman Dawes and David Abrahams Author of several books on C Nicolai Josuttis contributed the Boost array library in There are mailing lists devoted to Boost library use and library development active as of update License edit Boost is licensed under its own free open source license known as the Boost Software License It is a permissive license in the style of the BSD license and the MIT license The license has been OSI approved since February and is considered a free software license compatible with the GNU General Public License by the Free Software Foundation See also edit Free software portal GLib the equivalent upon which GNOME is built KDE Frameworks the equivalent upon which KDE Software Compilation is built Apache Portable Runtime used by the Apache HTTP Server Standard Template Library List of C template libraries References edit Library Technical Report JTC SC WG The C Standards Committee July Retrieved February Asio web site Spirit web site Boost Mailing Lists A K A Discussion Groups Retrieved October Boost mailing list archive Boost Software License BSL Open Source Initiative Various Licenses and Comments about Them GNU Project Free Software Foundation FSF Further reading edit Demming Robert amp Duffy Daniel J Introduction to the Boost C Libraries Volume Foundations Datasim ISBN Demming Robert amp Duffy Daniel J Introduction to the Boost C Libraries Volume Advanced Libraries Datasim ISBN Mukherjee Arindam Learning Boost C Libraries Packt ISBN Polukhin Antony Boost C Application Development Cookbook Packt ISBN Sch ling Boris The Boost C Libraries XML Press ISBN Sch ling Boris The Boost C Libraries ed XML Press p ISBN Siek Jeremy G Lee Lie Quan amp Lumsdaine Andrew The Boost Graph Library User Guide and Reference Manual Addison Wesley ISBN External links edit The Wikibook C Programming has a page on the topic of Libraries Boost Official website Retrieved from https en wikipedia org w index php title Boost C B B libraries amp oldid Categories C C libraries Free computer libraries Free software programmed in C Generic programming Software using the Boost license Hidden categories All articles with unsourced statements Articles with unsourced statements from January Articles containing potentially dated statements from All articles containing potentially dated statements Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Featured content Current events Random article Donate to Wikipedia Wikipedia store Interaction Help About Wikipedia Community portal Recent changes Contact page Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Cite this page Print export Create a book Download as PDF Printable version In other projects Wikimedia Commons Languages Deutsch Espa ol Fran ais Italiano Nederlands Norsk bokm l Polski Portugu s Edit links This page was last modified on January at Text is available under the Creative Commons Attribution ShareAlike License additional terms may apply By using this site you agree to the Terms of Use and Privacy Policy Wikipedia is a registered trademark of the Wikimedia Foundation Inc a non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Cookie statement Mobile view Regular expression Wikipedia the free encyclopedia Regular expression From Wikipedia the free encyclopedia Jump to navigation search The regexp lt A Z matches at least two spaces occurring after period and before an upper case letter as highlighted in the text above In theoretical computer science and formal language theory a regular expression sometimes called a rational expression is a sequence of characters that define a search pattern mainly for use in pattern matching with strings or string matching i e find and replace like operations The concept arose in the s when the American mathematician Stephen Kleene formalized the description of a regular language and came into common use with the Unix text processing utilities ed an editor and grep a filter In modern usage regular expressions are often distinguished from the derived but fundamentally distinct concepts of regex or regexp which no longer describe a regular language See below for details Regexps are so useful in computing that the various systems to specify regexps have evolved to provide both a basic and extended standard for the grammar and syntax modern regexps heavily augment the standard Regexp processors are found in several search engines search and replace dialogs of several word processors and text editors and in the command lines of text processing utilities such as sed and AWK Many programming languages provide regexp capabilities some built in for example Perl JavaScript Ruby AWK and Tcl and others via a standard library for example NET languages Java Python POSIX C and C since C Most other languages offer regexps via a library Contents Patterns History Basic concepts Formal language theory Formal definition Expressive power and compactness Deciding equivalence of regular expressions Syntax Delimiters Standards POSIX basic and extended POSIX extended Character classes Perl Lazy matching Patterns for non regular languages Fuzzy regexps Implementations and running times Unicode Uses Examples Induction See also Notes References External links Patterns edit The phrase regular expressions and consequently regexps is often used to mean the specific standard textual syntax distinct from the mathematical notation described below for representing patterns that matching text need to conform to Each character in a regular expression that is each character in the string describing its pattern is understood to be a metacharacter with its special meaning or a regular character with its literal meaning Together they can be used to identify textual material of a given pattern or process a number of instances of it Pattern matches can vary from a precise equality to a very general similarity controlled by the metacharacters The metacharacter syntax is designed specifically to represent prescribed targets in a concise and flexible way to direct the automation of text processing of a variety of input data in a form easy to type using standard ASCII keyboard A very simple case of a regular expression in this syntax would be to locate the same word spelled two different ways in a text editor the regular expression seriali sz e matches both serialise and serialize Wildcards could also achieve this but are more limited in what they can pattern having fewer metacharacters and a simple language base The usual context of wildcard characters is in globbing similar names in a list of files whereas regexps are usually employed in applications that pattern match text strings in general For example the regexp t t matches excess whitespace at the beginning or end of a line An advanced regexp used to match any numeral is d d d eE d See Examples for more examples Translating the Kleene star s zero or more of s A regexp processor translates a regular expression in the above syntax into an internal representation which can be executed and matched against a string representing the text being searched in One possible approach is the Thompson s construction algorithm to construct a nondeterministic finite automaton NFA which is then made deterministic and the resulting DFA is run on the target text string to recognize substrings that match the regular expression The picture shows the NFA scheme N s obtained from the regular expression s where s denotes a simpler regular expression in turn which has already been recursively translated to the NFA N s History edit Regular expressions originated in when mathematician Stephen Cole Kleene described regular languages using his mathematical notation called regular sets These arose in theoretical computer science in the subfields of automata theory models of computation and the description and classification of formal languages Other early implementations of pattern matching include the SNOBOL language which did not use regular expressions but instead its own pattern matching constructs Regular expressions entered popular use from in two uses pattern matching in a text editor and lexical analysis in a compiler Among the first appearances of regular expressions in program form was when Ken Thompson built Kleene s notation into the editor QED as a means to match patterns in text files For speed Thompson implemented regular expression matching by just in time compilation JIT to IBM code on the Compatible Time Sharing System an important early example of JIT compilation He later added this capability to the Unix editor ed which eventually led to the popular search tool grep s use of regular expressions grep is a word derived from the command for regular expression searching in the ed editor g re p meaning Global search for Regular Expression and Print matching lines Around the same time when Thompson developed QED a group of researchers including Douglas T Ross implemented a tool based on regular expressions that is used for lexical analysis in compiler design Many variations of these original forms of regular expressions were used in Unix programs at Bell Labs in the s including vi lex sed AWK and expr and in other programs such as Emacs Regexps were subsequently adopted by a wide range of programs with these early forms standardized in the POSIX standard in In the s the more complicated regexps arose in Perl which originally derived from a regex library written by Henry Spencer who later wrote an implementation of Advanced Regular Expressions for Tcl The Tcl library is a hybrid NFA DFA implementation with improved performance characteristics earning praise from Jeffrey Friedl who said it really seems quite wonderful Software projects that have adopted Spencer s Tcl regular expression implementation include PostgreSQL Perl later expanded on Spencer s original library to add many new features but has not yet caught up with Spencer s Advanced Regular Expressions implementation in terms of performance or Unicode handling Part of the effort in the design of Perl is to improve Perl s regexp integration and to increase their scope and capabilities to allow the definition of parsing expression grammars The result is a mini language called Perl rules which are used to define Perl grammar as well as provide a tool to programmers in the language These rules maintain existing features of Perl x regexps but also allow BNF style definition of a recursive descent parser via sub rules The use of regexps in structured information standards for document and database modeling started in the s and expanded in the s when industry standards like ISO SGML precursored by ANSI GCA consolidated The kernel of the structure specification language standards consists of regexps Its use is evident in the DTD element group syntax Starting in Philip Hazel developed PCRE Perl Compatible Regular Expressions which attempts to closely mimic Perl s regexp functionality and is used by many modern tools including PHP and Apache HTTP Server Today regexps are widely supported in programming languages text processing programs particular lexers advanced text editors and some other programs Regexp support is part of the standard library of many programming languages including Java and Python and is built into the syntax of others including Perl and ECMAScript Implementations of regexp functionality is often called a regexp engine and a number of libraries are available for reuse Basic concepts edit A regular expression often called a pattern is an expression used to specify a set of strings required for a particular purpose A simple way to specify a finite set of strings is to list its elements or members However there are often more concise ways to specify the desired set of strings For example the set containing the three strings Handel H ndel and Haendel can be specified by the pattern H ae ndel we say that this pattern matches each of the three strings In most formalisms if there exists at least one regular expression that matches a particular set then there exists an infinite number of other regular expression that also match it the specification is not unique Most formalisms provide the following operations to construct regular expressions Boolean or A vertical bar separates alternatives For example gray grey can match gray or grey Grouping Parentheses are used to define the scope and precedence of the operators among other uses For example gray grey and gr a e y are equivalent patterns which both describe the set of gray or grey Quantification A quantifier after a token such as a character or group specifies how often that preceding element is allowed to occur The most common quantifiers are the question mark the asterisk derived from the Kleene star and the plus sign Kleene plus The question mark indicates zero or one occurrences of the preceding element For example colou r matches both color and colour The asterisk indicates zero or more occurrences of the preceding element For example ab c matches ac abc abbc abbbc and so on The plus sign indicates one or more occurrences of the preceding element For example ab c matches abc abbc abbbc and so on but not ac n The preceding item is matched exactly n times min The preceding item is matched min or more times min max The preceding item is matched at least min times but not more than max times These constructions can be combined to form arbitrarily complex expressions much like one can construct arithmetical expressions from numbers and the operations and For example H ae ndel and H a ae ndel are both valid patterns which match the same strings as the earlier example H ae ndel The precise syntax for regular expressions varies among tools and with context more detail is given in the Syntax section Formal language theory edit Regular expressions describe regular languages in formal language theory They have the same expressive power as regular grammars Formal definition edit Regular expressions consist of constants and operator symbols that denote sets of strings and operations over these sets respectively The following definition is standard and found as such in most textbooks on formal language theory Given a finite alphabet the following constants are defined as regular expressions empty set denoting the set empty string denoting the set containing only the empty string which has no characters at all literal character a in denoting the set containing only the character a Given regular expressions R and S the following operations over them are defined to produce regular expressions concatenation RS denotes the set of strings that can be obtained by concatenating a string in R and a string in S For example ab c d ef abd abef cd cef alternation R S denotes the set union of sets described by R and S For example if R describes ab c and S describes ab d ef expression R S describes ab c d ef Kleene star R denotes the smallest superset of set described by R that contains and is closed under string concatenation This is the set of all strings that can be made by concatenating any finite number including zero of strings from set described by R For example is the set of all finite binary strings including the empty string and ab c ab c abab abc cab cc ababab abcab To avoid parentheses it is assumed that the Kleene star has the highest priority then concatenation and then alternation If there is no ambiguity then parentheses may be omitted For example ab c can be written as abc and a b c can be written as a bc Many textbooks use the symbols or for alternation instead of the vertical bar Examples a b denotes a b bb bbb a b denotes the set of all strings with no symbols other than a and b including the empty string a b aa ab ba bb aaa ab c denotes the set of strings starting with a then zero or more b s and finally optionally a c a ac ab abc abb abbc denotes the set of binary numbers that are multiples of Expressive power and compactness edit The formal definition of regular expressions is purposely parsimonious and avoids defining the redundant quantifiers and which can be expressed as follows a aa and a a Sometimes the complement operator is added to give a generalized regular expression here R c matches all strings over that do not match R In principle the complement operator is redundant as it can always be circumscribed by using the other operators However the process for computing such a representation is complex and the result may require expressions of a size that is double exponentially larger Regular expressions in this sense can express the regular languages exactly the class of languages accepted by deterministic finite automata There is however a significant difference in compactness Some classes of regular languages can only be described by deterministic finite automata whose size grows exponentially in the size of the shortest equivalent regular expressions The standard example here is the languages L k consisting of all strings over the alphabet a b whose k th from last letter equals a On one hand a regular expression describing L is given by Generalizing this pattern to L k gives the expression On the other hand it is known that every deterministic finite automaton accepting the language L k must have at least k states Luckily there is a simple mapping from regular expressions to the more general nondeterministic finite automata NFAs that does not lead to such a blowup in size for this reason NFAs are often used as alternative representations of regular languages NFAs are a simple variation of the type grammars of the Chomsky hierarchy Finally it is worth noting that many real world regular expression engines implement features that cannot be described by the regular expressions in the sense of formal language theory rather they implement regexps See below for more on this Deciding equivalence of regular expressions edit As seen in many of the examples above there is more than one way to construct a regular expression to achieve the same results It is possible to write an algorithm that for two given regular expressions decides whether the described languages are equal the algorithm reduces each expression to a minimal deterministic finite state machine and determines whether they are isomorphic equivalent The redundancy can be eliminated by using Kleene star and set union to find an interesting subset of regular expressions that is still fully expressive but perhaps their use can be restricted clarification needed This is a surprisingly difficult problem As simple as the regular expressions are there is no method to systematically rewrite them to some normal form The lack of axiom in the past led to the star height problem In Dexter Kozen axiomatized regular expressions with Kleene algebra see Kleene algebra History for details Syntax edit A regexp pattern matches a target string The pattern is composed of a sequence of atoms An atom is a single point within the regexp pattern which it tries to match to the target string The simplest atom is a literal but grouping parts of the pattern to match an atom will require using as metacharacters Metacharacters help form atoms quantifiers telling how many atoms and whether it is a greedy quantifier or not a logical OR character which offers a set of alternatives and a logical NOT character which negates an atom s existence and back references to refer to previous atoms of a completing pattern of atoms A match is made not when all the atoms of the string are matched but rather when all the pattern atoms in the regexp have matched The idea is to make a small pattern of characters stand for a large number of possible strings rather than compiling a large list of all the literal possibilities Depending on the regexp processor there are about fourteen metacharacters characters that may or may not have their literal character meaning depending on context or whether they are escaped i e preceded by an escape sequence in this case the backslash Modern and POSIX extended regexps use metacharacters more often than their literal meaning so to avoid backslash osis it makes sense to have a metacharacter escape to a literal mode but starting out it makes more sense to have the four bracketing metacharacters and be primarily literal and escape this usual meaning to become metacharacters Common standards implement both The usual metacharacters are and The usual characters that become metacharacters when escaped are dsw DSW and N Delimiters edit When entering a regexp in a programming language they may be represented as a usual string literal hence usually quoted this is common in C Java and Python for instance where the regexp re is entered as re However they are often written with slashes as delimiters as in re for the regexp re This originates in ed where is the editor command for searching and an expression re can be used to specify a range of lines matching the pattern which can be combined with other commands on either side most famously g re p as in grep global regex print which is included in most Unix based operating systems such as Linux distributions A similar convention is used in sed where search and replace is given by s regexp replacement and patterns can be joined with a comma to specify a range of lines as in re re This notation is particularly well known due to its use in Perl where it forms part of the syntax distinct from normal string literals In some cases such as sed and Perl alternative delimiters can be used to avoid collision with contents and to avoid having to escape occurrences of the delimiter character in the contents For example in sed the command s X will replace a with an X using commas as delimiters Standards edit The IEEE POSIX standard has three sets of compliance BRE ERE and SRE for Basic Extended and Simple Regular Expressions SRE is deprecated in favor of BRE as both provide backward compatibility The subsection below covering the character classes applies to both BRE and ERE BRE and ERE work together ERE adds and and it removes the need to escape the metacharacters and which are required in BRE Furthermore as long as the POSIX standard syntax for regexps is adhered to there can be and often is additional syntax to serve specific yet POSIX compliant applications Although POSIX leaves some implementation specifics undefined BRE and ERE provide a standard which has since been adopted as the default syntax of many tools where the choice of BRE or ERE modes is usually a supported option For example GNU grep has the following options grep E for ERE and grep G for BRE the default and grep P for Perl regexps Perl regexps have become a de facto standard having a rich and powerful set of atomic expressions Perl has no basic or extended levels where the and may or may not have literal meanings They are always metacharacters as they are in extended mode for POSIX To get their literal meaning you escape them Other metacharacters are known to be literal or symbolic based on context alone Perl offers much more functionality lazy regexps backtracking named capture groups and recursive patterns all of which are powerful additions to POSIX BRE ERE See lazy quantification below POSIX basic and extended edit In the POSIX standard Basic Regular Syntax BRE requires that the metacharacters and be designated and whereas Extended Regular Syntax ERE does not Metacharacter Description Matches any single character many applications exclude newlines and exactly which characters are considered newlines is flavor character encoding and platform specific but it is safe to assume that the line feed character is included Within POSIX bracket expressions the dot character matches a literal dot For example a c matches abc etc but a c matches only a or c A bracket expression Matches a single character that is contained within the brackets For example abc matches a b or c a z specifies a range which matches any lowercase letter from a to z These forms can be mixed abcx z matches a b c x y or z as does a cx z The character is treated as a literal character if it is the last or the first after the if present character within the brackets abc abc Note that backslash escapes are not allowed The character can be included in a bracket expression if it is the first after the character abc Matches a single character that is not contained within the brackets For example abc matches any character other than a b or c a z matches any single character that is not a lowercase letter from a to z Likewise literal characters and ranges can be mixed Matches the starting position within the string In line based tools it matches the starting position of any line Matches the ending position of the string or the position just before a string ending newline In line based tools it matches the ending position of any line Defines a marked subexpression The string matched within the parentheses can be recalled later see the next entry n A marked subexpression is also called a block or capturing group BRE mode requires n Matches what the n th marked subexpression matched where n is a digit from to This construct is vaguely defined in the POSIX standard Some tools allow referencing more than nine capturing groups Matches the preceding element zero or more times For example ab c matches ac abc abbbc etc xyz matches x y z zx zyx xyzzy and so on ab matches ab abab ababab and so on m n Matches the preceding element at least m and not more than n times For example a matches only aaa aaaa and aaaaa This is not found in a few older instances of regexps BRE mode requires m n Examples at matches any three character string ending with at including hat cat and bat hc at matches hat and cat b at matches all strings matched by at except bat hc at matches all strings matched by at other than hat and cat hc at matches hat and cat but only at the beginning of the string or line hc at matches hat and cat but only at the end of the string or line matches any single character surrounded by and since the brackets are escaped for example a and b s matches s followed by zero or more characters for example s and saw and seed POSIX extended edit The meaning of metacharacters escaped with a backslash is reversed for some characters in the POSIX Extended Regular Expression ERE syntax With this syntax a backslash causes the metacharacter to be treated as a literal character So for example is now and is now Additionally support is removed for n backreferences and the following metacharacters are added Metacharacter Description Matches the preceding element zero or one time For example ab c matches only ac or abc Matches the preceding element one or more times For example ab c matches abc abbc abbbc and so on but not ac The choice also known as alternation or set union operator matches either the expression before or the expression after the operator For example abc def matches abc or def Examples hc at matches hat cat hhat chat hcat cchchat and so on but not at hc at matches hat cat and at hc at matches hat cat hhat chat hcat cchchat at and so on cat dog matches cat or dog POSIX Extended Regular Expressions can often be used with modern Unix utilities by including the command line flag E Character classes edit The character class is the most basic regexp concept after a literal match It makes one small sequence of characters match a larger set of characters For example A Z could stand for the upper case alphabet and d could mean any digit Character classes apply to both POSIX levels When specifying a range of characters such as a Z i e lowercase a to upper case z the computer s locale settings determine the contents by the numeric ordering of the character encoding They could store digits in that sequence or the ordering could be abc zABC Z or aAbBcC zZ So the POSIX standard defines a character class which will be known by the regexp processor installed Those definitions are in the following table POSIX Non standard Perl Tcl Vim ASCII Description alnum A Za z Alphanumeric characters word w w A Za z Alphanumeric characters plus W W A Za z Non word characters alpha a A Za z Alphabetic characters blank s t Space and tab b lt gt lt W w lt w W Word boundaries cntrl x x F x F Control characters digit d d Digits D D Non digits graph x x E Visible characters lower l a z Lowercase letters print p x x E Visible characters and the space character punct amp lt gt Punctuation characters space s s t r n v f Whitespace characters S S t r n v f Non whitespace characters upper u A Z Uppercase letters xdigit x A Fa f Hexadecimal digits POSIX character classes can only be used within bracket expressions For example upper ab matches the uppercase letters and lowercase a and b An additional non POSIX class understood by some tools is word which is usually defined as alnum plus underscore This reflects the fact that in many programming languages these are the characters that may be used in identifiers The editor Vim further distinguishes word and word head classes using the notation w and h since in many programming languages the characters that can begin an identifier are not the same as those that can occur in other positions Note that what the POSIX regexp standards call character classes are commonly referred to as POSIX character classes in other regexp flavors which support them With most other regexp flavors the term character class is used to describe what POSIX calls bracket expressions Perl edit Because of its expressive power and relative ease of reading many other utilities and programming languages have adopted syntax similar to Perl s for example Java JavaScript Python Ruby Microsoft s NET Framework and XML Schema Some languages and tools such as Boost and PHP support multiple regexp flavors Perl derivative regexp implementations are not identical and usually implement a subset of features found in Perl released in Perl sometimes does incorporate features initially found in other languages for example Perl implements syntactic extensions originally developed in PCRE and Python Lazy matching edit The three common quantifiers and are greedy by default because they match as many characters as possible The regexp applied to the string Ganymede he continued is the largest moon in the Solar System matches the entire sentence instead of only the first quotation The aforementioned quantifiers may therefore be made lazy or minimal matching as few characters as possible by appending a question mark matches only the first quotation Patterns for non regular languages edit Many features found in virtually all modern regular expression libraries provide an expressive power that far exceeds the regular languages For example many implementations allow grouping subexpressions with parentheses and recalling the value they match in the same expression backreferences This means that among other things a pattern can match strings of repeated words like papa or WikiWiki called squares in formal language theory The pattern for these strings is The language of squares is not regular nor is it context free due to the pumping lemma However pattern matching with an unbounded number of back references as supported by numerous modern tools is still context sensitive However many tools libraries and engines that provide such constructions still use the term regular expression for their patterns This has led to a nomenclature where the term regular expression has different meanings in formal language theory and pattern matching For this reason some people have taken to using the term regex regexp or simply pattern to describe the latter Larry Wall author of the Perl programming language writes in an essay about the design of Perl Regular expressions are only marginally related to real regular expressions Nevertheless the term has grown with the capabilities of our pattern matching engines so I m not going to try to fight linguistic necessity here I will however generally call them regexes or regexen when I m in an Anglo Saxon mood Fuzzy regexps edit This section does not cite any sources Please help improve this section by adding citations to reliable sources Unsourced material may be challenged and removed September Variants of regexps can be used for working with text in natural language when it is necessary to take into account possible typos and spelling variants For example the text Julius Caesar might be a fuzzy match for Gaius Julius Caesar Yulius Cesar G Juliy Caezar In such cases the mechanism implements some fuzzy string matching algorithm and possibly some algorithm for finding the similarity between text fragment and pattern This task is closely related to both full text search and named entity recognition Some software libraries work with fuzzy regexps TRE well developed portable free project in C which uses syntax similar to POSIX FREJ open source project in Java with non standard syntax which utilizes prefix Lisp like notation targeted to allow easy use of substitutions of inner matched fragments in outer blocks but lacks many features of standard regexps agrep command line utility proprietary but free for non commercial usage Implementations and running times edit There are at least three different algorithms that decide whether and how a given regexp matches a string The oldest and fastest relies on a result in formal language theory that allows every nondeterministic finite automaton NFA to be transformed into a deterministic finite automaton DFA The DFA can be constructed explicitly and then run on the resulting input string one symbol at a time Constructing the DFA for a regular expression of size m has the time and memory cost of O m but it can be run on a string of size n in time O n An alternative approach is to simulate the NFA directly essentially building each DFA state on demand and then discarding it at the next step This keeps the DFA implicit and avoids the exponential construction cost but running cost rises to The explicit approach is called the DFA algorithm and the implicit approach the NFA algorithm Adding caching to the NFA algorithm is often called the lazy DFA algorithm or just the DFA algorithm without making a distinction These algorithms are fast but using them for recalling grouped subexpressions lazy quantification and similar features is tricky The third algorithm is to match the pattern against the input string by backtracking This algorithm is commonly called NFA but this terminology can be confusing Its running time can be exponential which simple implementations exhibit when matching against expressions like a aa b that contain both alternation and unbounded quantification and force the algorithm to consider an exponentially increasing number of sub cases This behavior can cause a security problem called Regular expression Denial of Service Although backtracking implementations only give an exponential guarantee in the worst case they provide much greater flexibility and expressive power For example any implementation which allows the use of backreferences or implements the various extensions introduced by Perl must include some kind of backtracking Some implementations which try to provide the best of both algorithms by first running a fast DFA algorithm and revert to a potentially slower backtracking algorithm only when a backreference is encountered during the match Unicode edit In theoretical terms any token set can be matched by regular expressions as long as it is pre defined In terms of historical implementations regexps were originally written to use ASCII characters as their token set though regexp libraries have supported numerous other character sets Many modern regexp engines offer at least some support for Unicode In most respects it makes no difference what the character set is but some issues do arise when extending regexps to support Unicode Supported encoding Some regexp libraries expect to work on some particular encoding instead of on abstract Unicode characters Many of these require the UTF encoding while others might expect UTF or UTF In contrast Perl and Java are agnostic on encodings instead operating on decoded characters internally Supported Unicode range Many regexp engines support only the Basic Multilingual Plane that is the characters which can be encoded with only bits Currently only a few regexp engines e g Perl s and Java s can handle the full bit Unicode range Extending ASCII oriented constructs to Unicode For example in ASCII based implementations character ranges of the form x y are valid wherever x and y have code points in the range x x F and codepoint x codepoint y The natural extension of such character ranges to Unicode would simply change the requirement that the endpoints lie in x x F to the requirement that they lie in x FFFF However in practice this is often not the case Some implementations such as that of gawk do not allow character ranges to cross Unicode blocks A range like x x F is valid since both endpoints fall within the Basic Latin block as is x x since both endpoints fall within the Armenian block but a range like x x is invalid since it includes multiple Unicode blocks Other engines such as that of the Vim editor allow block crossing but the character values must not be more than apart Case insensitivity Some case insensitivity flags affect only the ASCII characters Other flags affect all characters Some engines have two different flags one for ASCII the other for Unicode Exactly which characters belong to the POSIX classes also varies Cousins of case insensitivity As ASCII has case distinction case insensitivity became a logical feature in text searching Unicode introduced alphabetic scripts without case like Devanagari For these case sensitivity is not applicable For scripts like Chinese another distinction seems logical between traditional and simplified In Arabic scripts insensitivity to initial medial final and isolated position may be desired In Japanese insensitivity between hiragana and katakana is sometimes useful Normalization Unicode has combining characters Like old typewriters plain letters can be followed by one of more non spacing symbols usually diacritics like accent marks to form a single printing character but also provides precomposed characters i e characters that already include one or more combining characters A sequence of a character combining character should be matched with the identical single precomposed character The process of standardizing sequences of characters combining characters is called normalization New control codes Unicode introduced amongst others byte order marks and text direction markers These codes might have to be dealt with in a special way Introduction of character classes for Unicode blocks scripts and numerous other character properties Block properties are much less useful than script properties because a block can have code points from several different scripts and a script can have code points from several different blocks In Perl and the java util regex library properties of the form p InX or p Block X match characters in block X and P InX or P Block X matches code points not in that block Similarly p Armenian p IsArmenian or p Script Armenian matches any character in the Armenian script In general p X matches any character with either the binary property X or the general category X For example p Lu p Uppercase Letter or p GC Lu matches any upper case letter Binary properties that are not general categories include p White Space p Alphabetic p Math and p Dash Examples of non binary properties are p Bidi Class Right to Left p Word Break A Letter and p Numeric Value Uses edit Regexps are useful in a wide variety of text processing tasks and more generally string processing where the data need not be textual Common applications include data validation data scraping especially web scraping data wrangling simple parsing the production of syntax highlighting systems and many other tasks While regexps would be useful on Internet search engines processing them across the entire database could consume excessive computer resources depending on the complexity and design of the regex Although in many cases system administrators can run regex based queries internally most search engines do not offer regex support to the public Notable exceptions Google Code Search Exalead However Google Code Search has been shut down as of March better source needed Examples edit The specific syntax rules vary depending on the specific implementation programming language or library in use Additionally the functionality of regex implementations can vary between versions Despite this variability and because regexps can be difficult to both explain and understand without examples Interactive web sites for testing regexps are a useful resource for learning regexps by experimentation This section provides a basic description of some of the properties of regexps by way of illustration The following conventions are used in the examples metacharacter s the metacharacters column specifies the regex syntax being demonstrated m indicates a regex match operation in Perl s indicates a regex substitution operation in Perl Also worth noting is that these regexps are all Perl like syntax Standard POSIX regular expressions are different Unless otherwise indicated the following examples conform to the Perl programming language release January This means that other implementations may lack support for some parts of the syntax shown here e g basic vs extended regex vs or lack of d instead of POSIX digit The syntax and conventions used in these examples coincide with that of other programming environments as well Meta character s Description Example Normally matches any character except a newline Within square brackets the dot is literal string Hello World n if string m print string has length gt n Output Hello World has length gt Groups a series of pattern elements to a single element When you match a pattern within parentheses you can use any of later to refer to the previously matched pattern string Hello World n if string m H o print We matched and n Output We matched Hel and o W Matches the preceding pattern element one or more times string Hello World n if string m l print There are one or more consecutive letter l s in string n Output There are one or more consecutive letter l s in Hello World Matches the preceding pattern element zero or one times string Hello World n if string m H e print There is an H and a e separated by print characters Ex He Hoe n Output There is an H and a e separated by characters Ex He Hoe Modifies the or M N d regex that comes before to match as few times as possible string Hello World n if string m l o print The non greedy match with l followed by one or n print more characters is llo rather than llo Wo n Output The non greedy match with l followed by one or more characters is llo rather than llo Wo Matches the preceding pattern element zero or more times string Hello World n if string m el o print There is an e followed by zero to many print l followed by o eo elo ello elllo n Output There is an e followed by zero to many l followed by o eo elo ello elllo M N Denotes the minimum M and the maximum N match count string Hello World n if string m l print There exists a substring with at least print and at most l s in string n Output There exists a substring with at least and at most l s in Hello World Denotes a set of possible character matches string Hello World n if string m aeiou print string contains one or more vowels n Output Hello World contains one or more vowels Separates alternate possibilities string Hello World n if string m Hello Hi Pogo print At least one of Hello Hi or Pogo is print contained in string n Output At least one of Hello Hi or Pogo is contained in Hello World b Matches a zero width boundary between a word class character see next and either a non word class character or an edge string Hello World n if string m llo b print There is a word that ends with llo n Output There is a word that ends with llo w Matches an alphanumeric character including same as A Za z in ASCII and p Alphabetic p GC Mark p GC Decimal Number p GC Connector Punctuation in Unicode where the Alphabetic property contains more than just Letters and the Decimal Number property contains more than string Hello World n if string m w print There is at least one alphanumeric print character in string A Z a z n Output There is at least one alphanumeric character in Hello World A Z a z W Matches a non alphanumeric character excluding same as A Za z in ASCII and p Alphabetic p GC Mark p GC Decimal Number p GC Connector Punctuation in Unicode string Hello World n if string m W print The space between Hello and print World is not alphanumeric n Output The space between Hello and World is not alphanumeric s Matches a whitespace character which in ASCII are tab line feed form feed carriage return and space in Unicode also matches no break spaces next line and the variable width spaces amongst others string Hello World n if string m s s print There are TWO whitespace characters which may print be separated by other characters in string Output There are TWO whitespace characters which may be separated by other characters in Hello World S Matches anything BUT a whitespace string Hello World n if string m S S print There are TWO non whitespace characters which print may be separated by other characters in string Output There are TWO non whitespace characters which may be separated by other characters in Hello World d Matches a digit same as in ASCII in Unicode same as the p Digit or p GC Decimal Number property which itself the same as the p Numeric Type Decimal property string bottles of beer on the wall if string m d print is the first number in string n Output is the first number in bottles of beer on the wall D Matches a non digit same as in ASCII or P Digit in Unicode string Hello World n if string m D print There is at least one character in string print that is not a digit n Output There is at least one character in Hello World that is not a digit Matches the beginning of a line or string string Hello World n if string m He print string starts with the characters He n Output Hello World starts with the characters He Matches the end of a line or string string Hello World n if string m rld print string is a line or string print that ends with rld n Output Hello World is a line or string that ends with rld A Matches the beginning of a string but not an internal line string Hello nWorld n if string m AH print string is a string print that starts with H n Output Hello World is a string that starts with H z Matches the end of a string but not an internal line string Hello nWorld n if string m d n z print string is a string print that ends with d n n Output Hello World is a string that ends with d n Matches every character except the ones inside brackets string Hello World n if string m abc print string contains a character other than print a b and c n Output Hello World contains a character other than a b and c Induction edit Main article Induction of regular languages Regular expressions can often be created induced or learned based on a set of example strings This is known as the induction of regular languages and is part of the general problem of grammar induction in computational learning theory Formally given examples of strings in a regular language and perhaps also given examples of strings not in that regular language it is possible to induce a grammar for the language i e a regular expression that generates that language Not all regular languages can be induced in this way see language identification in the limit but many can For example the set of examples and negative set of counterexamples can be used to induce the regular expression followed by zero or more s See also edit Comparison of regular expression engines Extended Backus Naur Form List of regular expression software applications which support regular expressions Regular tree grammar Thompson s construction algorithm converts a regular expression into an equivalent nondeterministic finite automaton NFA Notes edit Ruslan Mitkov The Oxford Handbook of Computational Linguistics Oxford University Press p ISBN Mark V Lawson September Finite Automata CRC Press pp ISBN Kleene a b Thompson a b Johnson et al Kernighan Brian A Regular Expressions Matcher Beautiful Code O Reilly Media pp ISBN Retrieved Ritchie Dennis M An incomplete history of the QED Text Editor Retrieved October a b Aho amp Ullman Bibliographic Notes for Chapter p Aycock JIT Compilation Techniques Genesis p Raymond Eric S citing Dennis Ritchie Jargon File grep New Regular Expression Features in Tcl Retrieved Friedl Jeffrey The Mechanics of Expression Processing Mastering Regular Expressions O Reilly Media p ISBN PostgreSQL Documentation Pattern Matching Retrieved Wall Larry and the Perl development team perlre Perl regular expressions Unicode and Localisation Support Retrieved Russ Cox Regular Expression Matching Can Be Simple And Fast but is slow in Java Perl PHP Python Ruby Retrieved a b Wall a b c grep man page a b Hopcroft Motwani amp Ullman Sipser Gelade amp Neven Gruber amp Holzer Kozen page needed ISO IEC Information technology Portable Operating System Interface POSIX Part Shell and Utilities successively revised as ISO IEC Information technology Portable Operating System Interface POSIX Part System Interfaces ISO IEC and currently ISO IEC IEEE Information technology Portable Operating System Interface POSIX Base Specifications Issue The Single Unix Specification Version Perl Regular Expression Documentation perldoc perl org Retrieved January a b Regular Expression Syntax Python documentation Python Software Foundation Retrieved October Cezar C mpeanu and Kai Salomaa and Sheng Yu Dec A Formal Study of Practical Regular Expressions International Journal of Foundations of Computer Science Theorem p Cox Laurikari Vim documentation pattern Vimdoc sourceforge net Retrieved a b UTS on Unicode Regular Expressions Annex A Character Blocks Retrieved Replacement for Google Code Search The character m is not always required to specify a Perl match operation For example m abc could also be rendered as abc The m is only necessary if the user wishes to specify a match operation without using a forward slash as the regex delimiter Sometimes it is useful to specify an alternate regex delimiter in order to avoid delimiter collision See perldoc perlre for more details e g see Java in a Nutshell Page Python Scripting for Computational Science Page Programming PHP Page Note that all the if statements return a TRUE value Conway Damian Regular Expressions End of String Perl Best Practices O Reilly p ISBN References edit Aho Alfred V van Leeuwen Jan ed Algorithms for finding patterns in strings Handbook of Theoretical Computer Science volume A Algorithms and Complexity The MIT Press pp Aho Alfred V Ullman Jeffrey D Chapter Patterns Automata and Regular Expressions PDF Foundations of Computer Science Regular Expressions The Single UNIX Specification Version The Open Group Chapter Regular Expressions The Open Group Base Specifications Issue IEEE Std Edition The Open Group Cox Russ Regular Expression Matching Can Be Simple and Fast Forta Ben Sams Teach Yourself Regular Expressions in Minutes Sams ISBN Friedl Jeffrey Mastering Regular Expressions O Reilly ISBN Gelade Wouter Neven Frank Succinctness of the Complement and Intersection of Regular Expressions Proceedings of the th International Symposium on Theoretical Aspects of Computer Science STACS pp Goyvaerts Jan Levithan Steven Regular Expressions Cookbook O reilly ISBN Gruber Hermann Holzer Markus Finite Automata Digraph Connectivity and Regular Expression Size PDF Proceedings of the th International Colloquium on Automata Languages and Programming ICALP pp doi Habibi Mehran Real World Regular Expressions with Java Springer ISBN Hopcroft John E Motwani Rajeev Ullman Jeffrey D Introduction to Automata Theory Languages and Computation nd ed Addison Wesley Johnson W L Porter J H Ackley S I Ross D T Automatic generation of efficient lexical processors using finite state techniques Communications of the ACM doi Kleene Stephen C Shannon Claude E McCarthy John eds Representation of Events in Nerve Nets and Finite Automata Automata Studies Princeton University Press pp Kozen Dexter A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events Proceedings of the th Annual IEEE Symposium on Logic in Computer Science LICS Laurikari Ville TRE library Liger Francois Craig McQueen Paul Wilton Visual Basic NET Text Manipulation Handbook Wrox Press ISBN Sipser Michael Chapter Regular Languages Introduction to the Theory of Computation PWS Publishing pp ISBN X Stubblebine Tony Regular Expression Pocket Reference O Reilly ISBN X Thompson K Programming Techniques Regular expression search algorithm Communications of the ACM doi Wall Larry Apocalypse Pattern Matching External links edit Wikibooks has a book on the topic of Regular Expressions The Wikibook R Programming has a page on the topic of Text Processing Regular Expressions at DMOZ ISO IEC Information technology Portable Operating System Interface POSIX Part Shell and Utilities ISO IEC Information technology Portable Operating System Interface POSIX Part System Interfaces ISO IEC Information technology Portable Operating System Interface POSIX Part System Interfaces ISO IEC IEEE Information technology Portable Operating System Interface POSIX Base Specifications Issue v t e Automata theory formal languages and formal grammars Chomsky hierarchy Grammars Languages Abstract machines Type Type Type Type Unrestricted no common name Context sensitive Positive range concatenation Indexed Linear context free rewriting systems Tree adjoining Context free Deterministic context free Visibly pushdown Regular Non recursive Recursively enumerable Decidable Context sensitive Positive range concatenation Indexed Linear context free rewriting language Tree adjoining Context free Deterministic context free Visibly pushdown Regular Star free Finite Turing machine Decider Linear bounded PTIME Turing Machine Nested stack Thread automaton Embedded pushdown Nondeterministic pushdown Deterministic pushdown Visibly pushdown Finite Counter free with aperiodic finite monoid Acyclic finite Each category of languages except those marked by a is a proper subset of the category directly above it Any language in each category is generated by a grammar and by an automaton in the category in the same line v t e Strings String metric Approximate string matching Bitap algorithm Damerau Levenshtein distance Edit distance Hamming distance Jaro Winkler distance Lee distance Levenshtein automaton Levenshtein distance Wagner Fischer algorithm String searching algorithm Apostolico Giancarlo algorithm Boyer Moore string search algorithm Boyer Moore Horspool algorithm Knuth Morris Pratt algorithm Rabin Karp string search algorithm Multiple string searching Aho Corasick Commentz Walter algorithm Rabin Karp Regular expression Comparison of regular expression engines List of regular expression software Regular tree grammar Thompson s construction Nondeterministic finite automaton Sequence alignment Hirschberg s algorithm Needleman Wunsch algorithm Smith Waterman algorithm Data structures DAFSA Suffix array Suffix automaton Suffix tree Generalized suffix tree Rope Ternary search tree Trie Other Parsing Pattern matching Compressed pattern matching Longest common subsequence Longest common substring Sequential pattern mining Sorting Authority control GND NDL Retrieved from https en wikipedia org w index php title Regular expression amp oldid Categories Automata computation Formal languages Pattern matching Programming constructs Regular expressions Hidden categories Pages with syntax highlighting errors Wikipedia articles needing page number citations from February Wikipedia articles needing clarification from February Articles needing additional references from September All articles needing additional references All articles with specifically marked weasel worded phrases Articles with specifically marked weasel worded phrases from June All articles lacking reliable references Articles lacking reliable references from September Articles with DMOZ links Wikipedia articles with GND identifiers Articles with example code Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Featured content Current events Random article Donate to Wikipedia Wikipedia store Interaction Help About Wikipedia Community portal Recent changes Contact page Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Cite this page Print export Create a book Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Languages Catal e tina Dansk Deutsch Espa ol Esperanto Euskara Fran ais Galego Hrvatski slenska Italiano Latvie u Magyar Mirand s Nederlands Norsk bokm l Polski Portugu s Rom n Shqip Simple English Sloven ina srpski Suomi Svenska T rk e Ti ng Vi t Walon Edit links This page was last modified on February at Text is available under the Creative Commons Attribution ShareAlike License additional terms may apply By using this site you agree to the Terms of Use and Privacy Policy Wikipedia is a registered trademark of the Wikimedia Foundation Inc a non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Cookie statement Mobile view 